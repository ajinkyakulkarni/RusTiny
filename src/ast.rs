//! RusTiny's Abstract Syntax Tree
//!
//! This is the representation of a RusTiny program. It's generated by the parser
//! and passed to the `middle end` after doing some analysis.

use std::collections::HashMap;
use std::fmt;
use std::mem;
use std::ops::Deref;
use std::str::FromStr;
use driver;


// --- Types and Values ---------------------------------------------------------

pub enum Type {
    Bool,
    Int,
    Char,
    Unit
}

impl FromStr for Type {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, ()> {
        match s {
            "bool" => Ok(Type::Bool),
            "int"  => Ok(Type::Int),
            "char" => Ok(Type::Char),
            _ => Err(())
        }
    }
}


pub enum Value {
    Bool(bool),
    Int(u32),
    Char(char)
}


// --- Operators ----------------------------------------------------------------

#[derive(Copy, Eq, PartialEq, Hash)]
pub enum UnOp {
    /// `!`
    Not,
    /// `-`, not actually used because the lexer doesn't know the difference
    /// between UnOp::Neg and BinOp::Sub and always uses the latter.
    Neg  // TODO: Think about removing this
}

#[derive(Copy, Eq, PartialEq, Hash)]
pub enum BinOp {
    /// `+`
    Add,
    /// `-`
    Sub,
    /// `*`
    Mul,
    /// `/`
    Div,
    /// `%`
    Mod,
    /// `**`
    Pow,
    /// `&%`
    And,
    /// `||`
    Or,
    /// `^`
    BitXor,
    /// `&`
    BitAnd,
    /// `|`
    BitOr,
    /// `<<`
    Shl,
    /// `>>`
    Shr,
    /// `==`
    EqEq,
    /// `<`
    Lt,
    /// `<=`
    Le,
    /// `!=`
    Ne,
    /// `>=`
    Ge,
    /// `>`
    Gt
}


// --- The AST itself -----------------------------------------------------------
// Note: Box<T> is used almost everywhere where elements are nested in other elements
//       because otherwise there might be infinite loops (an expression containing an expression)
//       which can't be expressed without indirection (Box<T> in this case).
//       Introduces a lot of indirection, but does the job anyway.

/// A node in the AST
///
/// Will eventually contain additional information about the node's source location
/// (span) and an unique node id.
// TODO: Add span & id
pub struct Node<T> {
    node: T,
}

impl<T> Node<T> {
    pub fn new(t: T) -> Node<T> {
        Node { node: t }
    }

    pub fn unwrap(self) -> T {
        self.node
    }
}

/// Allows to get a reference to the content by dereferencing (`*node`)
impl<T> Deref for Node<T> {
    type Target = T;

    fn deref<'a>(&'a self) -> &'a T {
        &self.node
    }
}


/// A program is a list of symbols
pub type Program = Vec<Node<Symbol>>;


/// A top level symbol
pub enum Symbol {
    /// A function
    Function {
        name: Ident,
        bindings: Vec<Node<Binding>>,
        ret_ty: Type,
        body: Box<Node<Block>>,
        local_vars: HashMap<Ident, Type>  // TODO: Store variables associated with a `Block` instead
    },

    /// A static value (can be modified at runtime)
    Static {
        binding: Box<Node<Binding>>,
        value: Value
    },

    /// A constant value. Usages will be replaced with the value at compilation time
    Constant {
        binding: Box<Node<Binding>>,
        value: Value
    }
}


/// A block of statements (e.g. function body, if body, ...)
pub struct Block {
    pub stmts: Vec<Node<Statement>>,
    pub expr: Option<Box<Node<Expression>>>  // FIXME: Use a Unit expr instead?
}


/// A binding of a value to a name (e.g. local variable, function argument)
pub struct Binding {
    pub ty: Type,
    pub name: Ident
}


/// A declaration or an expression terminated with a semicolon
pub enum Statement {
    Declaration {
        binding: Box<Node<Binding>>,
        value: Box<Node<Expression>>
    },
    Expression {
        val: Box<Node<Expression>>
    }
}


/// An expression. The real 'meat' of the language.
///
/// The difference to statements is that they aren't terminated by a semicolon
/// and can be used in a very flexible way:
///
/// ```ignore
/// a = if a == 2 { 1 } else { 0 }
/// ```
pub enum Expression {
    /// A literal value
    Literal {
        val: Value
    },

    /// A variable referenced by name
    Variable {
        name: Ident
    },

    /// An assignment expression
    Assign {
        lhs: Box<Node<Expression>>,
        rhs: Box<Node<Expression>>
    },

    /// An assignment expression with an additional operator (ex: `a += 1`)
    AssignOp {
        op: BinOp,
        lhs: Box<Node<Expression>>,
        rhs: Box<Node<Expression>>
    },

    /// Exit the function with an optional return value
    Return {
        val: Option<Box<Node<Expression>>>
    },

    /// A function call
    Call {
        func: Box<Node<Expression>>,
        args: Vec<Node<Expression>>
    },

    /// A grouped expression. Used for operator precedence, ex: `2 * (3 + 5)`,
    /// where `(3 + 5)` is stored in a group.
    Group(Box<Node<Expression>>),

    /// An expression with an infix operator (`2 + 5`, `a == false`)
    Infix {
        op: BinOp,
        lhs: Box<Node<Expression>>,
        rhs: Box<Node<Expression>>
    },

    // An expressoin with a prefix operator (`-2`, `!a`)
    Prefix {
        op: UnOp,
        item: Box<Node<Expression>>
    },

    /// A conditional with an optional `else` branch
    If {
        cond: Box<Node<Expression>>,
        conseq: Box<Node<Block>>,
        altern: Option<Box<Node<Block>>>
    },

    /// A while loop
    While {
        cond: Box<Node<Expression>>,
        body: Box<Node<Block>>,
    },

    /// Break out of a loop
    Break,

    //For  // There is currently no `for` loop! Rust uses `for x in iterator`, but
           // as RusTiny doesn't have iterators (or structs for that matter), that
           // wouldn't make much sense. Having a classical C-style for loop on the
           // other hand would be useful but can be abused much more...
}


/// An identifier refering to an interned string
#[derive(Copy, Eq, PartialEq, Hash)]
pub struct Ident(pub usize);

/// Allows the ident's name to be accessed by dereferencing (`*ident`)
impl Deref for Ident {
    type Target = str;

    fn deref<'a>(&'a self) -> &'a str {
        let interner = driver::get_interner();
        unsafe { mem::transmute(&*interner.resolve(*self)) }
    }
}


// --- Debug implementations ----------------------------------------------------

impl<T: fmt::Debug> fmt::Debug for Node<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self.node)
    }
}

impl fmt::Debug for Binding {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}: {:?}", self.name, self.ty)
    }
}

impl fmt::Debug for Type {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::Type::*;

        match *self {
            Bool    => write!(f, "bool"),
            Int     => write!(f, "int"),
            Char    => write!(f, "char"),
            Unit    => write!(f, "()")
        }
    }
}

impl fmt::Debug for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::Value::*;

        match *self {
            Bool(b) => write!(f, "{}", b),
            Int(i)  => write!(f, "{}", i),
            Char(c) => write!(f, "{}", c)
        }
    }
}

impl fmt::Debug for BinOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::BinOp::*;

        match *self {
            Add     => write!(f, "+"),
            Sub     => write!(f, "-"),
            Mul     => write!(f, "*"),
            Div     => write!(f, "/"),
            Mod     => write!(f, "%"),
            Pow     => write!(f, "**"),
            And     => write!(f, "&&"),
            Or      => write!(f, "||"),
            BitXor  => write!(f, "^"),
            BitAnd  => write!(f, "&"),
            BitOr   => write!(f, "|"),
            Shl     => write!(f, "<<"),
            Shr     => write!(f, ">>"),
            EqEq    => write!(f, "=="),
            Lt      => write!(f, "<"),
            Le      => write!(f, "<="),
            Ne      => write!(f, "!="),
            Ge      => write!(f, ">="),
            Gt      => write!(f, ">")
        }
    }
}

impl fmt::Debug for UnOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::UnOp::*;

        match *self {
            Neg     => write!(f, "-"),
            Not     => write!(f, "!")
        }
    }
}

impl fmt::Debug for Ident {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", driver::get_interner().resolve(*self))
    }
}