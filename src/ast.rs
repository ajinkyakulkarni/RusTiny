//! RusTiny's Abstract Syntax Tree
//!
//! This is the representation of a RusTiny program. It's generated by the parser
//! and passed to the *middle end* after doing some analysis.

use std::cell::Cell;
use std::fmt;
use std::mem;
use std::ops::{Add, Deref, DerefMut};
use std::str::FromStr;
use driver::session;


// --- Types and Values ---------------------------------------------------------

#[derive(Copy, Clone)]
pub enum Type {
    Bool,
    Int,
    Char,
    Unit
}

impl FromStr for Type {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, ()> {
        match s {
            "bool" => Ok(Type::Bool),
            "int"  => Ok(Type::Int),
            "char" => Ok(Type::Char),
            _ => Err(())
        }
    }
}


#[derive(Clone)]
pub enum Value {
    Bool(bool),
    Int(u32),
    Char(char)
}


// --- Operators ----------------------------------------------------------------

#[derive(Copy, Clone, Eq, PartialEq, Hash)]
pub enum UnOp {
    /// `!`
    Not,
    /// `-`, not actually used because the lexer doesn't know the difference
    /// between UnOp::Neg and BinOp::Sub and always uses the latter.
    Neg  // TODO: Think about removing this
}

#[derive(Copy, Clone, Eq, PartialEq, Hash)]
pub enum BinOp {
    /// `+`
    Add,
    /// `-`
    Sub,
    /// `*`
    Mul,
    /// `/`
    Div,
    /// `%`
    Mod,
    /// `**`
    Pow,
    /// `&%`
    And,
    /// `||`
    Or,
    /// `^`
    BitXor,
    /// `&`
    BitAnd,
    /// `|`
    BitOr,
    /// `<<`
    Shl,
    /// `>>`
    Shr,
    /// `==`
    EqEq,
    /// `<`
    Lt,
    /// `<=`
    Le,
    /// `!=`
    Ne,
    /// `>=`
    Ge,
    /// `>`
    Gt
}


// --- The AST itself -----------------------------------------------------------
// Note: Box<T> is used almost everywhere where elements are nested in other elements
//       because otherwise there might be infinite loops (an expression containing an expression).
//       Introduces a lot of indirection, but does the job anyway.

#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct NodeId(u32);

impl NodeId {
    pub fn as_u32(&self) -> u32 {
        let NodeId(i) = *self;
        i
    }
}


#[derive(Copy, Clone, Debug)]
pub struct Span {
    pub pos: u32,  // 0-indexed
    pub len: u32
}

impl Add for Span {
    type Output = Span;

    fn add(self, rhs: Span) -> Span {
        Span {
            pos: self.pos,
            len: rhs.pos + rhs.len - self.pos
        }
    }
}

pub const EMPTY_SPAN: Span = Span { pos: 0, len: 0 };


pub struct Spanned<T> {
    pub value: T,
    pub span: Span
}

impl<T> Spanned<T> {
    pub fn new(t: T, lo: u32, hi: u32) -> Spanned<T> {
        Spanned { value: t, span: Span { pos: lo, len: hi - lo } }
    }
}


/// A node in the AST
///
/// Will eventually contain additional information about the node's source location
/// (span) and an unique node id.
#[derive(Clone)]
pub struct Node<T> {
    node: T,
    pub span: Span,
    pub id: NodeId
}

impl<T> Node<T> {
    pub fn new(t: T, s: Span) -> Node<T> {
        thread_local!{
            static CURRENT_NODE_ID: Cell<u32> = Cell::new(0)
        };
        let node_id = CURRENT_NODE_ID.with(|c| {
            let id = c.get();
            c.set(id + 1);
            id
        });

        Node { node: t, span: s, id: NodeId(node_id) }
    }

    pub fn unwrap(self) -> T {
        self.node
    }
}

/// Allows to get a reference to the content by dereferencing (`*node`)
impl<T> Deref for Node<T> {
    type Target = T;

    fn deref<'a>(&'a self) -> &'a T {
        &self.node
    }
}

impl<T> DerefMut for Node<T> {
    fn deref_mut<'a>(&'a mut self) -> &'a mut T {
        &mut self.node
    }
}


/// A program is a list of symbols
pub type Program = Vec<Node<Symbol>>;


/// A top level symbol
#[derive(Clone)]
pub enum Symbol {
    /// A function
    Function {
        name: Node<Ident>,
        bindings: Vec<Node<Binding>>,
        ret_ty: Type,
        body: Box<Node<Block>>
    },

    /// A static value (can be modified at runtime)
    Static {
        binding: Box<Node<Binding>>,
        value: Value
    },

    /// A constant value. Usages will be replaced with the value at compilation time
    Constant {
        binding: Box<Node<Binding>>,
        value: Value
    }
}

impl Symbol {
    pub fn get_ident(&self) -> Ident {
        match *self {
            Symbol::Function { ref name, .. } => **name,
            Symbol::Static   { ref binding, .. } => *binding.name,
            Symbol::Constant { ref binding, .. } => *binding.name,
        }
    }

    /// Clone the current symbol but strip the body if it's a function
    // FIXME: Is there a better solution?
    pub fn clone_without_body(&self) -> Symbol {
        match *self {
            Symbol::Static { .. } | Symbol::Constant { .. } => (*self).clone(),
            Symbol::Function { ref name, ref bindings, ref ret_ty, body: _ } => {
                Symbol::Function {
                    name: (*name).clone(),
                    bindings: (*bindings).clone(),
                    ret_ty: *ret_ty,
                    body: Box::new(Node::new(Block { stmts: vec![],
                                                     expr: Box::new(Node::new(Expression::Unit, EMPTY_SPAN)) },
                                             EMPTY_SPAN))
                }
            }
        }
    }
}


/// A block of statements (e.g. function body, if body, ...)
#[derive(Clone)]
pub struct Block {
    pub stmts: Vec<Node<Statement>>,
    pub expr: Box<Node<Expression>>
}


/// A binding of a value to a name (e.g. local variable, function argument)
#[derive(Clone)]
pub struct Binding {
    pub ty: Type,
    pub name: Node<Ident>
}


/// A declaration or an expression terminated with a semicolon
#[derive(Clone)]
pub enum Statement {
    Declaration {
        binding: Box<Node<Binding>>,
        value: Box<Node<Expression>>
    },
    Expression {
        val: Box<Node<Expression>>
    }
}


/// An expression. The real 'meat' of the language.
///
/// The difference to statements is that they aren't terminated by a semicolon
/// and can be used in a very flexible way:
///
/// ```ignore
/// a = if a == 2 { 1 } else { 0 }
/// ```
#[derive(Clone)]
pub enum Expression {
    /// A literal value
    Literal {
        val: Value
    },

    /// A variable referenced by name
    Variable {
        name: Node<Ident>
    },

    /// An assignment expression
    Assign {
        lhs: Box<Node<Expression>>,
        rhs: Box<Node<Expression>>
    },

    /// An assignment expression with an additional operator (ex: `a += 1`)
    AssignOp {
        op: BinOp,
        lhs: Box<Node<Expression>>,
        rhs: Box<Node<Expression>>
    },

    /// Exit the function with an optional return value
    Return {
        val: Box<Node<Expression>>
    },

    /// A function call
    Call {
        func: Box<Node<Expression>>,
        args: Vec<Node<Expression>>
    },

    /// A grouped expression. Used for operator precedence, ex: `2 * (3 + 5)`,
    /// where `(3 + 5)` is stored in a group.
    Group(Box<Node<Expression>>),

    /// An expression with an infix operator (`2 + 5`, `a == false`)
    Infix {
        op: BinOp,
        lhs: Box<Node<Expression>>,
        rhs: Box<Node<Expression>>
    },

    // An expressoin with a prefix operator (`-2`, `!a`)
    Prefix {
        op: UnOp,
        item: Box<Node<Expression>>
    },

    /// A conditional with an optional `else` branch
    If {
        cond: Box<Node<Expression>>,
        conseq: Box<Node<Block>>,
        altern: Option<Box<Node<Block>>>
    },

    /// A while loop
    While {
        cond: Box<Node<Expression>>,
        body: Box<Node<Block>>,
    },

    /// Break out of a loop
    Break,

    //For  // There is currently no `for` loop! Rust uses `for x in iterator`, but
           // as RusTiny doesn't have iterators (or structs for that matter), that
           // wouldn't make much sense. Having a classical C-style for loop on the
           // other hand would be useful but can be abused much more...

    /// An expression without any content
    Unit
}


/// An identifier refering to an interned string
#[derive(Copy, Clone, Eq, PartialEq, Hash)]
pub struct Ident(pub usize);

/// Allows the ident's name to be accessed by dereferencing (`*ident`)
impl Deref for Ident {
    type Target = str;

    fn deref<'a>(&'a self) -> &'a str {
        unsafe { mem::transmute(&*(session().interner.resolve(*self))) }
    }
}


// --- Debug implementations ----------------------------------------------------

impl<T: fmt::Debug> fmt::Debug for Spanned<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self.value)
    }
}

impl<T: fmt::Debug> fmt::Debug for Node<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self.node)
    }
}

impl fmt::Debug for Binding {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}: {:?}", self.name, self.ty)
    }
}

impl fmt::Debug for Type {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::Type::*;

        match *self {
            Bool    => write!(f, "bool"),
            Int     => write!(f, "int"),
            Char    => write!(f, "char"),
            Unit    => write!(f, "()")
        }
    }
}

impl fmt::Debug for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::Value::*;

        match *self {
            Bool(b) => write!(f, "{}", b),
            Int(i)  => write!(f, "{}", i),
            Char(c) => write!(f, "{}", c)
        }
    }
}

impl fmt::Debug for BinOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::BinOp::*;

        match *self {
            Add     => write!(f, "+"),
            Sub     => write!(f, "-"),
            Mul     => write!(f, "*"),
            Div     => write!(f, "/"),
            Mod     => write!(f, "%"),
            Pow     => write!(f, "**"),
            And     => write!(f, "&&"),
            Or      => write!(f, "||"),
            BitXor  => write!(f, "^"),
            BitAnd  => write!(f, "&"),
            BitOr   => write!(f, "|"),
            Shl     => write!(f, "<<"),
            Shr     => write!(f, ">>"),
            EqEq    => write!(f, "=="),
            Lt      => write!(f, "<"),
            Le      => write!(f, "<="),
            Ne      => write!(f, "!="),
            Ge      => write!(f, ">="),
            Gt      => write!(f, ">")
        }
    }
}

impl fmt::Debug for UnOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::UnOp::*;

        match *self {
            Neg     => write!(f, "-"),
            Not     => write!(f, "!")
        }
    }
}

impl fmt::Debug for Ident {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", session().interner.resolve(*self))
    }
}